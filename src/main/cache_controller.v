//==============================================================================
// File: cache_controller.v
// Description:
//   Top‐level cache controller that ties together a finite‐state control unit
//   with a multi‐set, 4‐way set‐associative cache memory. The control unit
//   generates read/write requests, random addresses, and data; captures hit/miss
//   feedback and per‐way ages; and drives per‐way age‐update masks. The cache
//   memory receives those control signals, performs tag lookup, data read/write,
//   and LRU age maintenance. This module’s outputs include the read data byte
//   and a hit/miss indicator for the most recent operation.
//
// Parameters:
//   ADDRESS_WORD_SIZE – Width of the full memory address bus (default: 32 bits).
//   TAG_SIZE          – Number of high‐order tag bits used for each cache line (default: 19).
//   BLOCK_SIZE        – Number of words per cache block (default: 16 words).
//   WORD_SIZE         – Number of bytes per word (default: 4 bytes).
//   NUMBER_OF_SETS    – Total number of cache sets (must be power of two; default: 128).
//
// Ports:
//   input  clk                        – System clock. Rising edge drives control and memory.
//   input  rst_b                      – Active‐low reset. Initializes control unit and cache memory.
//   input  opcode                     – Single‐bit command: 0 → issue a read, 1 → issue a write.
//   output [7:0] data                 – Byte read from cache on a read hit (garbage on miss).
//   output        hit_miss            – High (1) if the most recent access was a cache hit.
//
// Internal Signals:
//   wire        hit_miss_w            – Hit/miss feedback from the cache memory (to control unit).
//   wire [3:0]  hit_miss_set          – One‐hot per‐way mask from the selected cache set.
//   wire [7:0]  ages                  – Concatenated 4×2‐bit age vectors from the active set.
//   wire [ADDRESS_WORD_SIZE-1:0] address_word
//                                      – Random or chosen address, generated by control unit.
//   wire        try_read              – Asserted for one cycle by control unit to request a read.
//   wire        try_write             – Asserted for one cycle by control unit to request a write.
//   wire [7:0]  write_data            – Random data byte for write operations, from control unit.
//   wire [3:0]  reset_age             – One‐hot mask: which way in the active set should clear its age.
//   wire [3:0]  increment_age         – One‐hot mask: which ways in the active set should increment their ages.
//
// Submodules:
//   • control_unit – Generates and sequences cache read/write requests, random addresses and data,
//                    watches hit/miss feedback, and computes per‐way age masks in its UPDATE_AGES state.
//   • cache_memory – Implements a NUMBER_OF_SETS × 4‐way set‐associative cache. Uses a decoder + tri‐states
//                    to route control signals into exactly one set; then multiplexes outputs back to top level.
//
// Behavior Summary:
//   1) On reset, control_unit enters IDLE and stable signals (address_word=0, try_read/try_write=0, etc.).
//   2) control_unit waits for `opcode`, then issues either a one‐cycle `try_read` or `try_write` with a
//      random `address_word` (and `write_data` if write). It transitions to CHECK_STATUS.
//   3) In CHECK_STATUS, the control FSM waits one cycle for `hit_miss_w` and `hit_miss_set` feedback from cache_memory.
//      • If hit_miss_w=1, control_unit goes to UPDATE_AGES immediately.
//      • If hit_miss_w=0, it stalls two cycles to simulate memory fill, then goes to UPDATE_AGES.
//   4) In UPDATE_AGES, control_unit scans `hit_miss_set[3:0]` to find which way matched (or “replaced” on miss).
//      • It asserts `reset_age[i]=1` for that way i → clears its internal age to 0.
//      • It then asserts `increment_age[j]=1` for any other way j whose age (extracted from `ages[2*j +: 2]`)
//        is numerically less than the chosen way’s age → increments their ages by 1.
//      • After assembling those two one‐hot masks, control_unit returns to IDLE.
//   5) Meanwhile, cache_memory routes `address_word`, `try_read`, `try_write`, `write_data`, `reset_age`, and
//      `increment_age` into the selected set via a 7→128 decoder + tri‐state drivers. That set’s four_way_set logic
//      then uses those signals to handle tag lookup, data access, and LRU updates internally. The resulting
//      `data`, `ages`, `hit_miss_w`, and `hit_miss_set` come back to top level.
//   6) Top level simply passes `hit_miss_w` to the `hit_miss` output, and presents `data` output from cache_memory.
//
//==============================================================================

module cache_controller #(
    parameter ADDRESS_WORD_SIZE = 32,  // Full address width (bits)
    parameter TAG_SIZE          = 19,  // Number of tag bits per address
    parameter BLOCK_SIZE        = 16,  // Words per cache block
    parameter WORD_SIZE         = 4,   // Bytes per word
    parameter NUMBER_OF_SETS    = 128  // Number of sets (must be 2^k)
) (
    input  wire       clk,      // System clock
    input  wire       rst_b,    // Active‐low reset
    input  wire       opcode,   // 0→read, 1→write
    output wire [7:0] data,     // Data byte read (valid on hit)
    output wire       hit_miss  // High on cache hit, low on miss
);

    //-------------------------------------------------------------------------
    // Internal wires connecting control_unit and cache_memory
    //-------------------------------------------------------------------------
    wire                         hit_miss_w;  // Hit/miss feedback from cache_memory
    wire [                  3:0] hit_miss_set;  // One‐hot way mask from the active set
    wire [                  7:0] ages;  // 4×2‐bit age vector from the active set
    wire [ADDRESS_WORD_SIZE-1:0] address_word;
    wire                         try_read;
    wire                         try_write;
    wire [                  7:0] write_data;
    wire [                  3:0] reset_age;
    wire [                  3:0] increment_age;

    //-------------------------------------------------------------------------
    // Instantiate the finite-state control unit
    //-------------------------------------------------------------------------
    control_unit #(
        .ADDRESS_WORD_SIZE(ADDRESS_WORD_SIZE)
    ) u_control (
        .clk          (clk),
        .rst_b        (rst_b),
        .opcode       (opcode),
        .hit_miss     (hit_miss_w),
        .hit_miss_set (hit_miss_set),
        .ages         (ages),
        .address_word (address_word),
        .try_read     (try_read),
        .try_write    (try_write),
        .write_data   (write_data),
        .reset_age    (reset_age),
        .increment_age(increment_age)
    );

    //-------------------------------------------------------------------------
    // Instantiate the cache memory (NUMBER_OF_SETS × 4‐way set)
    //-------------------------------------------------------------------------
    cache_memory #(
        .ADDRESS_WORD_SIZE(ADDRESS_WORD_SIZE),
        .TAG_SIZE         (TAG_SIZE),
        .BLOCK_SIZE       (BLOCK_SIZE),
        .WORD_SIZE        (WORD_SIZE),
        .NUMBER_OF_SETS   (NUMBER_OF_SETS)
    ) u_cache (
        .clk          (clk),
        .rst_b        (rst_b),
        .address_word (address_word),
        .try_read     (try_read),
        .try_write    (try_write),
        .write_data   (write_data),
        .reset_age    (reset_age),
        .increment_age(increment_age),
        .data         (data),
        .ages         (ages),
        .hit_miss     (hit_miss_w),
        .hit_miss_set (hit_miss_set)
    );

    // Expose hit/miss from the cache to the top‐level output
    assign hit_miss = hit_miss_w;

endmodule
