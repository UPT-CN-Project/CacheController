//==============================================================================
// File: four_way_set.v
// Description:
//   Implements a four-way set-associative cache “set.” Contains four instances
//   of `cache_line`, each representing one “way” in the set. Coordinates read
//   and write requests, performs tag lookups, and applies an LRU (Least
//   Recently Used) eviction policy. On each access, determines which way hits
//   (if any), or allocates a new line in an empty way, or evicts the oldest
//   line. Also drives per-line age updates (reset or increment) so that LRU
//   ordering is maintained.
//
// Parameters:
//   ADDRESS_WORD_SIZE – Width of full address word in bits (e.g., 32).
//   TAG_SIZE          – Number of MSBs of address used as the cache tag.
//   BLOCK_SIZE        – Number of words per cache block (e.g., 16 words).
//   WORD_SIZE         – Bytes per word (e.g., 4 bytes).
//
// Ports:
//   input  clk                   – System clock. All internal state updates
//                                   occur on its rising edge (with async reset).
//   input  rst_b                 – Active-low reset. Clears all internal signals.
//   input  try_read              – Assert to perform a read access on this set.
//   input  try_write             – Assert to perform a write access on this set.
//   input  [ADDRESS_WORD_SIZE-1:0] address_word
//                                   – Full memory address for lookup. The top
//                                   TAG_SIZE bits form the tag; lower bits form
//                                   block-and-byte offsets passed to each line.
//   input  [7:0] write_data       – One byte to write on a write-hit or write-miss.
//
//   output [7:0] data             – Selected data byte from whichever way was
//                                   chosen (hit or newly allocated).
//   output [7:0] ages             – Concatenated 2-bit age counters for each way,
//                                   in order {age_way3, age_way2, age_way1, age_way0}.
//   output       hit_miss         – High if any way experienced a tag match & valid.
//   output [3:0] hit_miss_set     – One-hot mask of which way(s) hit (only one way
//                                   should ever match, but output allows visibility).
//
// Internal Signals:
//   reg    [3:0] ready            – One-hot index: which way “owns” the current
//                                   access (hit, empty allocation, or LRU eviction).
//   wire  [31:0] line_data        – Concatenation of the 4×8-bit `data` outputs from
//                                   each `cache_line` instance. Slice [8*i+7:8*i] is
//                                   way i’s output byte.
//   wire   [3:0] line_hit_miss     – Each way’s individual hit/miss flag (from each
//                                   `cache_line`). High if that way matched and was valid.
//   wire   [3:0] line_is_empty     – Each way’s “empty?” flag, from `cache_line`’s
//                                   `is_empty` output. High if that line is currently invalid.
//
//   wire  [1:0] sel               – 2-bit select generated by the 4→2 priority encoder
//                                   based on `ready`. Used to pick data/hit-miss from
//                                   the chosen way.
//   reg    [3:0] reset_age        – One-hot mask: resets age_bits of the winning way
//                                   (tag hit) to 0. Driven when `try_read || try_write`.
//   reg    [3:0] increment_age    – One-hot mask: increments age_bits of every other
//                                   way (including empties). Driven when `try_read || try_write`.
//
//   wire  [1:0] age_way0, age_way1, age_way2, age_way3
//                                   – Extracted 2-bit ages from the 8-bit `ages` bus.
//                                   Used to decide LRU victim when no hits/empties exist.
//
// Behavior Overview:
//   1) On each rising edge of `clk` (or when `rst_b` is deasserted):
//       • If `rst_b == 0`, clear `ready`, `reset_age`, `increment_age` to zero.
//       • Else:
//           a) Evaluate `line_hit_miss[]` (from each `cache_line`) to see if any
//              way is a hit.
//           b) If a hit exists (first nonzero index in `line_hit_miss`), set `ready`
//              one-hot to that way index.
//           c) Else if no hits, but some way is empty (`line_is_empty[i] == 1`),
//              choose the lowest-index empty way (i.e., way0 → way1 → way2 → way3).
//              Set `ready` to that way.
//           d) Else (no hits, no empties), choose the way with age == 2'b11 (LRU).
//              Among multiple candidates, the lower index wins due to the if/else chain.
//              Set `ready` to that way.
//           e) If both `try_read == 0` and `try_write == 0`, clear `reset_age` and
//              `increment_age` to zero. No age change.
//           f) If `try_read || try_write` is asserted, build two vectors:
//               • `reset_age = line_hit_miss` (only the winning/hit way resets its age).
//               • `increment_age = ~line_hit_miss` (all other ways, including empty ones,
//                  see their age_bits incremented by each cache_line on next posedge).
//   2) The 4→2 priority encoder (`encoder4to2`) consumes the `ready` one-hot and
//      produces a 2-bit index `sel`. If `ready == 0`, `sel` defaults to 0.
//   3) A 4-to-1 `mux4to1` (`mux_data_inst`) uses `sel` to pick the correct
//      8-bit data out of the concatenated `line_data[31:0]`. Similarly, another
//      `mux4to1` (`mux_hitmiss_inst`) selects the single-bit `hit_miss` signal
//      from the chosen way.
//   4) `hit_miss_set` is simply the 4-bit vector of per-way hit/miss flags (`line_hit_miss`).
//   5) `ages` is a concatenation of the 2-bit `age` outputs from each instantiated
//      `cache_line`. Bits [1:0] are age_way0, [3:2] age_way1, [5:4] age_way2, [7:6] age_way3.
//
// Usage Notes:
//   - Instantiate this module when building a 4-way set-associative cache. Four
//     `cache_line` instances handle per-line storage and tag matching. The set
//     logic here handles arbitration (hits vs. empty vs. LRU), data/miss multiplexing,
//     and age updates.
//   - To integrate into a full cache, connect `try_read`/`try_write` and `address_word`
//     from your CPU interface. On a miss, your higher-level FSM must service memory,
//     refill the evicted block (if dirty), and signal readiness for the next access.
//
// Example Instantiation:
//
//   four_way_set #(
//       .ADDRESS_WORD_SIZE(32),
//       .TAG_SIZE         (19),
//       .BLOCK_SIZE       (16),
//       .WORD_SIZE        (4)
//   ) my_cache_set (
//       .clk           (clk),
//       .rst_b         (rst_b),
//       .try_read      (cpu_try_read),
//       .try_write     (cpu_try_write),
//       .address_word  (cpu_address),
//       .write_data    (cpu_write_byte),
//
//       .data          (cache_data_out),
//       .ages          (cache_line_ages),
//       .hit_miss      (cache_hit),
//       .hit_miss_set  (which_way_hit)
//   );
//
//==============================================================================

module four_way_set #(
    parameter ADDRESS_WORD_SIZE = 32,  // Full address width
    parameter TAG_SIZE          = 19,  // Tag bits per cache line
    parameter BLOCK_SIZE        = 16,  // Words per cache block
    parameter WORD_SIZE         = 4    // Bytes per word
) (
    input wire                         clk,           // System clock
    input wire                         rst_b,         // Active-low reset
    input wire                         try_read,      // Read request for this set
    input wire                         try_write,     // Write request for this set
    input wire [ADDRESS_WORD_SIZE-1:0] address_word,  // Full address for lookup
    input wire [                  7:0] write_data,    // Byte to write on write request
    input wire [                  3:0] reset_age,     // One-hot: reset age for the hit way
    input wire [                  3:0] increment_age, // One-hot: increment age for all other ways

    output wire [7:0] data,         // Selected data byte from the chosen way
    output wire [7:0] ages,         // {age3, age2, age1, age0}, each 2 bits
    output wire       hit_miss,     // Asserted if any way hit
    output wire [3:0] hit_miss_set  // One-hot: which way(s) had a hit
);

    //-------------------------------------------------------------------------
    // Internal signals
    //-------------------------------------------------------------------------
    reg  [ 3:0] ready;  // One-hot: which way “owns” this access this cycle
    wire [31:0] line_data;  // Concatenate 4 × 8-bit data outputs from each cache_line
    wire [ 3:0] line_hit_miss;  // Each way’s per-line hit/miss indication
    wire [ 3:0] line_is_empty;  // Each way’s “is_empty” flag

    wire [ 1:0] sel;  // 2-bit select from 4→2 priority encoder based on `ready`

    // Extract the 2-bit age fields from the combined `ages` bus
    // ages = { age_way3, age_way2, age_way1, age_way0 }
    wire [ 1:0] age_way0 = ages[1:0];
    wire [ 1:0] age_way1 = ages[3:2];
    wire [ 1:0] age_way2 = ages[5:4];
    wire [ 1:0] age_way3 = ages[7:6];

    //-------------------------------------------------------------------------
    // 4→2 Priority Encoder
    //   If `ready[i]` is 1, then `sel` = i (binary). If none, sel = 2'b00.
    //-------------------------------------------------------------------------
    encoder4to2 enc4to2_inst (
        .in (ready),
        .out(sel)
    );

    //-------------------------------------------------------------------------
    // Instantiate four `cache_line` modules (way0..way3).
    // Each sees:
    //   - clk, rst_b
    //   - ready[i], try_read, try_write
    //   - write_data, address_word
    //   - reset_age[i], increment_age[i]
    //   - Outputs:
    //       • data byte → slice of line_data[31:0]
    //       • age (2 bits) → slice of ages[7:0]
    //       • hit_miss → line_hit_miss[i]
    //       • is_empty → line_is_empty[i]
    //-------------------------------------------------------------------------
    generate
        genvar i;
        for (i = 0; i < 4; i = i + 1) begin : cache_lines
            cache_line #(
                .ADDRESS_WORD_SIZE(ADDRESS_WORD_SIZE),
                .TAG_SIZE         (TAG_SIZE),
                .BLOCK_SIZE       (BLOCK_SIZE),
                .WORD_SIZE        (WORD_SIZE)
            ) line_inst (
                .clk          (clk),
                .rst_b        (rst_b),
                .ready        (ready[i]),
                .address_word (address_word),
                .try_read     (try_read),
                .try_write    (try_write),
                .write_data   (write_data),
                .reset_age    (reset_age[i]),
                .increment_age(increment_age[i]),

                // Map each line’s 8-bit data to a slice of line_data
                .data    (line_data[8*(i+1)-1 : 8*i]),
                // Map each line’s 2-bit age to its spot in ages bus
                .age     (ages[2*i+1 : 2*i]),
                .hit_miss(line_hit_miss[i]),
                .is_empty(line_is_empty[i])
            );
        end
    endgenerate

    // Expose the per-way hit/miss flags (one-hot). If any bit is 1, that's a hit.
    assign hit_miss_set = line_hit_miss;

    //-------------------------------------------------------------------------
    // Multiplexers to select data byte and hit/miss from the chosen way:
    //   - If `sel` selects way k, then data = line_data[8k+7:8k].
    //   - If no way is chosen (`ready = 4'b0000`), sel=2'b00; data=way0’s output,
    //     but hit_miss=0 in that case so CPU treats as miss.
    //-------------------------------------------------------------------------

    mux #(
        .SEL_WIDTH(2),  // 2 bits to select among 4 inputs
        .w        (8)   // each input is 8 bits wide
    ) data_mux_inst (
        .in (line_data),  // 32-bit bus: {way3[7:0], way2[7:0], way1[7:0], way0[7:0]}
        .sel(sel),        // 2-bit select
        .out(data)        // 8-bit selected output
    );

    mux #(
        .SEL_WIDTH(2),  // 2 bits to select among 4 inputs
        .w        (1)   // each input is 1 bit wide
    ) hitmiss_mux_inst (
        .in (line_hit_miss),  // 4-bit bus: {hit3, hit2, hit1, hit0}
        .sel(sel),            // 2-bit select
        .out(hit_miss)        // 1-bit selected output
    );

    //-------------------------------------------------------------------------
    // Sequential logic: determine `ready`, `reset_age`, and `increment_age`
    // on each rising edge of clk (with async reset). Uses LRU/empty/hit priority.
    //
    // Logic chain:
    //   1) If rst_b=0: clear ready, reset_age, increment_age.
    //   2) Else:
    //       a) If any line_hit_miss[i] = 1, choose that way (priority: 0→1→2→3).
    //       b) Else if any line_is_empty[i] = 1, choose first empty way (0→1→2→3).
    //       c) Else choose LRU: find i where age_way[i] == 2'b11 (oldest).
    //          Priority if multiple have max age: lowest index wins.
    //       d) If neither try_read nor try_write, hold reset_age/increment_age = 0.
    //       e) If try_read || try_write:
    //            • reset_age = line_hit_miss (one-hot only the hit way).
    //            • increment_age = ~line_hit_miss (one-hot all other ways,
    //              including empty lines so they age as well).
    //-------------------------------------------------------------------------
    always @(posedge clk or negedge rst_b) begin
        if (!rst_b) begin
            ready         <= 4'b0000;
            // reset_age     <= 4'b0000;
            // increment_age <= 4'b0000;
        end else begin
            // 1) Determine which way “owns” this access (hit > empty > LRU)
            if (line_hit_miss[0]) ready <= 4'b0001;  // way0 hit
            else if (line_hit_miss[1]) ready <= 4'b0010;  // way1 hit
            else if (line_hit_miss[2]) ready <= 4'b0100;  // way2 hit
            else if (line_hit_miss[3]) ready <= 4'b1000;  // way3 hit
            else if (line_is_empty[0]) ready <= 4'b0001;  // way0 empty
            else if (line_is_empty[1]) ready <= 4'b0010;  // way1 empty
            else if (line_is_empty[2]) ready <= 4'b0100;  // way2 empty
            else if (line_is_empty[3]) ready <= 4'b1000;  // way3 empty
            else if (age_way0 == 2'b11) ready <= 4'b0001;  // way0 LRU
            else if (age_way1 == 2'b11) ready <= 4'b0010;  // way1 LRU
            else if (age_way2 == 2'b11) ready <= 4'b0100;  // way2 LRU
            else if (age_way3 == 2'b11) ready <= 4'b1000;  // way3 LRU
            else ready <= 4'b0000;  // fallback (shouldn’t occur)

            // 2) Build reset_age & increment_age if an access is happening
            if (try_read || try_write) begin
                // Hit way resets its age; all others increment (including empties).
                // reset_age     <= line_hit_miss;  // one-hot: clear age of hit way
                // increment_age <= ~line_hit_miss;  // one-hot: increment all non-hit ways
            end else begin
                // reset_age     <= 4'b0000;
                // increment_age <= 4'b0000;
            end
        end
    end

endmodule
